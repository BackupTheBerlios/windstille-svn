Basic features that need to be handled by the physic/collision engine: 

* properly detection of the side at which two boxes collide so that the game can react as expected (player pushes a box, player jumps on a moving platform from below, player jumps on an enemy vs gets hit by an enemy, etc.)
* allow to stack crates, boxes and stuff
* allow to shoot in a stack of boxes and let the stack collapse
* conveyor belts
* slopes in the tilemap (not that important)

Stuff that is not needed:

* rotating boxes, while probally pretty, they cause more trouble then good, both on the programming side as well as on the gameplay side (what happens when you jump on a box which has a 45 degree angel?)

== Collision Domains ==

The collision detection should seperate different kind of objects into different collision domains, so that objects that are not in the same domain aren't checked at all against each other. Domains could be:

* CollidesWithPlayer
* CollidesWithEnemy
* CollidesWithProjectile
* ...

Domains could be implemented as a simple 'unsigned int' for the CollisionObject

== Collision Callback ==

Once a collision occured the engine should give the object usefull feedback for resolving the collision, the engine should *not* resolve collisions on there own. The callback might look like:

 CollisionObject::collision(CollisionEvent& collision);

 struct CollisionEvent
 {
  // is NONE actually needed?
  enum State { NONE, STUCK, COLLISION } state;

  // should be enough no need for a vector IMHO
  enum Side  { TOP, BOTTOM, LEFT, RIGHT };

  // the object which with 'this' collided
  CollisionObject* object;

  // the amount of time that has not yet been used up
  float rest_delta;
 };

Collision resolution could then either mean to change the direction, to simply halt or to attach oneself to the other object (ie. that is how moving platforms should find the player).